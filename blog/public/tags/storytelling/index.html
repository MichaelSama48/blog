<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Storytelling | Blog của Hoàng Anh</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/tags/storytelling/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css" integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/storytelling/index.xml" title="rss">
<link rel="alternate" hreflang="en" href="http://localhost:1313/tags/storytelling/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body class="list" id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Blog của Hoàng Anh (Alt + H)">Blog của Hoàng Anh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts" title="Blog (Bài viết)">
                    <span>Blog (Bài viết)</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Storytelling
  </h1>
</header>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="https://picsum.photos/seed/graphstructure/1600/900" alt="Complex Network Node">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">GraphQL vs REST: Cuộc Soán Ngôi Hay Chỉ Là Sự Cường Điệu?
    </h2>
  </header>
  <div class="entry-content">
    <p>Thế giới ngăn nắp của REST Hãy tưởng tượng REST giống như một thực đơn nhà hàng (Menu) cố định tại một quán ăn truyền thống. Bạn bước vào và nhìn thấy danh sách món:
Món 1 (GET /users/1): Thông tin chi tiết một người dùng (gồm tên, tuổi, địa chỉ, số đo 3 vòng…). Món 2 (GET /users/1/posts): Danh sách bài viết của người đó. Món 3 (GET /posts/1/comments): Bình luận của bài viết. Mọi thứ rất rõ ràng, quy củ. Bạn muốn ăn gì, phục vụ (Server) sẽ mang đúng món đó ra. Không thêm, không bớt. REST tuyệt vời vì sự đơn giản và chuẩn mực của nó. Cả thế giới đều hiểu REST. Các trình duyệt, các proxy server đều hỗ trợ cache cho REST cực tốt.
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-06-20 00:00:00 +0000 UTC'>June 20, 2024</span>&nbsp;·&nbsp;<span>4 min</span></footer>
  <a class="entry-link" aria-label="post link to GraphQL vs REST: Cuộc Soán Ngôi Hay Chỉ Là Sự Cường Điệu?" href="http://localhost:1313/posts/graphql-vs-rest/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="https://picsum.photos/seed/securelock/1600/900" alt="Cyber Lock">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Bức Tường Lửa Và Chìa Khóa Vàng: Chuyện Về Bảo Mật Mạng (CORS &amp; JWT)
    </h2>
  </header>
  <div class="entry-content">
    <p>Nỗi ám ảnh mang tên CORS Có lẽ trong cuộc đời làm Frontend Developer, không có dòng chữ màu đỏ nào gây ức chế, đau đầu và khiến bạn muốn đập bàn phím hơn: “Access to fetch at… has been blocked by CORS policy”.
Nó xuất hiện như một gáo nước lạnh tát vào mặt bạn ngay khi bạn vừa hoàn thành xong tính năng gọi API tuyệt vời. Bạn vò đầu bứt tai: “Tại sao? Code của tôi chạy ngon lành trên Postman mà? Tại sao trình duyệt lại ghét tôi? Tại sao nó chặn tôi?”.
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-06-18 00:00:00 +0000 UTC'>June 18, 2024</span>&nbsp;·&nbsp;<span>5 min</span></footer>
  <a class="entry-link" aria-label="post link to Bức Tường Lửa Và Chìa Khóa Vàng: Chuyện Về Bảo Mật Mạng (CORS & JWT)" href="http://localhost:1313/posts/network-security-jwt-cors/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="https://images.unsplash.com/photo-1611162617474-5b21e879e113?q=80&amp;w=1600&amp;auto=format&amp;fit=crop" alt="Video Conference">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">WebRTC: Khi Browsers Nhìn Thấy Nhau (Không Cần Server)
    </h2>
  </header>
  <div class="entry-content">
    <p>Nghịch lý của kẻ trung gian Chúng ta thường quen với mô hình Client-Server. A muốn gửi ảnh cho B, A phải upload lên Server, rồi B download từ Server về. Server đứng giữa như một bưu điện trung chuyển, kiểm soát mọi thứ.
Nhưng với Video Call lại là câu chuyện hoàn toàn khác. Video rất nặng (hàng MB mỗi giây). Nếu hàng triệu người cùng gọi video qua một Server trung gian, Server đó sẽ “nổ tung” vì quá tải băng thông. Và độ trễ (latency) sẽ khiến cuộc gọi bị giật lag, tiếng đi trước hình lả lướt theo sau, tạo ra trải nghiệm tồi tệ.
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-06-15 00:00:00 +0000 UTC'>June 15, 2024</span>&nbsp;·&nbsp;<span>4 min</span></footer>
  <a class="entry-link" aria-label="post link to WebRTC: Khi Browsers Nhìn Thấy Nhau (Không Cần Server)" href="http://localhost:1313/posts/js-webrtc/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="https://images.unsplash.com/photo-1550745165-9bc0b252726f?q=80&amp;w=1600&amp;auto=format&amp;fit=crop" alt="Abstract Network Nodes">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Khi Web Không Chỉ Là Tĩnh Lặng: Đánh Thức Sự Sống Với WebSockets
    </h2>
  </header>
  <div class="entry-content">
    <p>Sự im lặng đáng sợ của HTTP Hãy hình dung Internet truyền thống như một cuộc hội thoại một chiều tẻ nhạt. Bạn (Client) hỏi: “Có tin mới không?”. Server trả lời: “Không”. Bạn im lặng. Một lúc sau, bạn lại hỏi: “Có tin mới chưa?”. Server lại: “Chưa”.
Đó là cách Web hoạt động trong suốt hàng chục năm. HTTP là giao thức “Request - Response”. Server luôn ở thế bị động, nó không thể tự nhiên vỗ vai bạn và bảo: “Này, có tin nhắn kìa” nếu bạn không hỏi nó trước. Để làm những ứng dụng chat hay thông báo, người ta phải dùng kỹ thuật “Long Polling” - tức là cứ vài giây lại hỏi Server một lần. Nó giống như một đứa trẻ ngồi ghế sau cứ liên tục hỏi bố mẹ: “Sắp đến nơi chưa? Sắp đến nơi chưa?”. Rất phiền phức, tốn băng thông và làm chậm server một cách vô ích.
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-06-12 00:00:00 +0000 UTC'>June 12, 2024</span>&nbsp;·&nbsp;<span>3 min</span></footer>
  <a class="entry-link" aria-label="post link to Khi Web Không Chỉ Là Tĩnh Lặng: Đánh Thức Sự Sống Với WebSockets" href="http://localhost:1313/posts/js-websockets/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="https://images.unsplash.com/photo-1555066931-4365d14bab8c?q=80&amp;w=1600&amp;auto=format&amp;fit=crop" alt="Code editor">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Cuộc Chiến Giao Thức: Fetch API &#39;Cây Nhà Lá Vườn&#39; vs Axios &#39;Vũ Khí Hạng Nặng&#39;
    </h2>
  </header>
  <div class="entry-content">
    <p>Cái thời của XMLHttpRequest Đã từng có một thời, để gửi một request lên server, lập trình viên JS phải vật lộn với một con quái vật tên là XMLHttpRequest. Cú pháp rắc rối, callback hell tầng tầng lớp lớp khiến ai nhìn vào cũng muốn bỏ nghề. Mọi thứ rối rắm đến mức người ta phải dùng jQuery chỉ để gọi Ajax cho đỡ khổ.
Rồi bình minh lên, Fetch API xuất hiện như một tiêu chuẩn mới của trình duyệt, được tích hợp sẵn (Native). Nó dùng Promise, code nhìn sạch sẽ, thoáng đãng. Cảm giác như vừa chuyển từ nhà tranh vách đất lên chung cư cao cấp vậy.
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-06-10 00:00:00 +0000 UTC'>June 10, 2024</span>&nbsp;·&nbsp;<span>3 min</span></footer>
  <a class="entry-link" aria-label="post link to Cuộc Chiến Giao Thức: Fetch API &#39;Cây Nhà Lá Vườn&#39; vs Axios &#39;Vũ Khí Hạng Nặng&#39;" href="http://localhost:1313/posts/js-fetch-axios/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="https://images.unsplash.com/photo-1544256718-3bcf237f3974?q=80&amp;w=1600&amp;auto=format&amp;fit=crop" alt="Speeding Lights">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Đường Đua F1 Của Dữ Liệu: Tại Sao Netty và NIO Lại Nhanh Đến Vậy?
    </h2>
  </header>
  <div class="entry-content">
    <p>Cơn ác mộng mang tên 10K Connections Hãy tưởng tượng bạn là quản lý của một ngân hàng (Server). Mô hình cũ (Blocking I/O - BIO) hoạt động như sau: Mỗi khi có một khách hàng (Client) đến quầy, bạn phải cử riêng một nhân viên (Thread) ra tiếp. Nhân viên này sẽ ngồi chết dí với khách hàng đó.
Khách hàng điền đơn? Nhân viên ngồi nhìn. Khách hàng đếm tiền? Nhân viên ngồi nhìn. Khách hàng gọi điện cho vợ hỏi mã PIN? Nhân viên vẫn phải ngồi nhìn. Nhân viên chỉ được giải phóng khi khách hàng ra về. Điều này ổn nếu ngân hàng vắng. Nhưng nếu có 10.000 khách hàng ùa vào cùng lúc? Bạn cần 10.000 nhân viên! Không ngân hàng nào đủ tiền thuê (RAM) và đủ không gian chứa (CPU Context Switching) số lượng nhân viên khổng lồ đó. Hệ thống sụp đổ. Đây chính là vấn đề C10K huyền thoại đã từng làm đau đầu biết bao kỹ sư mạng.
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-06-08 00:00:00 +0000 UTC'>June 8, 2024</span>&nbsp;·&nbsp;<span>4 min</span></footer>
  <a class="entry-link" aria-label="post link to Đường Đua F1 Của Dữ Liệu: Tại Sao Netty và NIO Lại Nhanh Đến Vậy?" href="http://localhost:1313/posts/java-netty-nio/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="https://images.unsplash.com/photo-1549692520-acc6669e2f0c?q=80&amp;w=1600&amp;auto=format&amp;fit=crop" alt="Programmer Desk">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Nghệ Thuật Xây Dựng API: Spring Boot và Những Chuẩn Mực Bị Lãng Quên
    </h2>
  </header>
  <div class="entry-content">
    <p>Sự hỗn loạn trước khi có luật lệ Hãy quay ngược thời gian về những năm tháng hỗn loạn của Web sơ khai. Khi đó, mỗi trang web giao tiếp theo một kiểu. Người thì gửi XML cồng kềnh, người thì gửi chuỗi text trần trụi, người thì dùng SOAP với hàng tá thẻ bọc rối rắm. Việc tích hợp hai hệ thống giống như việc bắt một người nói tiếng Pháp nói chuyện với người nói tiếng Nhật. Không ai hiểu ai, và việc “nói chuyện” giữa các server là một cực hình.
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-06-05 00:00:00 +0000 UTC'>June 5, 2024</span>&nbsp;·&nbsp;<span>4 min</span></footer>
  <a class="entry-link" aria-label="post link to Nghệ Thuật Xây Dựng API: Spring Boot và Những Chuẩn Mực Bị Lãng Quên" href="http://localhost:1313/posts/spring-boot-rest-api/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="https://images.unsplash.com/photo-1551288049-bebda4e38f71?q=80&amp;w=1600&amp;auto=format&amp;fit=crop" alt="High Tech Data">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Kỷ Nguyên Mới Của Giao Tiếp: Java HttpClient và Sự Tinh Tế Của Asynchronous
    </h2>
  </header>
  <div class="entry-content">
    <p>Lời tạm biệt với quá khứ Nếu bạn là một lập trình viên Java lâu năm, chắc hẳn bạn đã từng trải qua nỗi đau mang tên HttpURLConnection. Cái tên dài ngoằng, cách sử dụng thì rườm rà, và cảm giác như bạn đang quay lại thời kỳ đồ đá mỗi khi phải viết 20 dòng code chỉ để gửi một cái GET request đơn giản.
Bạn phải mở connection, set method, check response code, đọc input stream line-by-line… Ôi chao, quá nhiều thủ tục hành chính cho một việc đơn giản là “Lấy dữ liệu”. Nhiều người đã bỏ cuộc và tìm đến những thư viện bên ngoài như Apache HttpClient hay OkHttp. Chúng tốt, nhưng việc thêm một đống dependency vào project đôi khi lại làm phình to file JAR của bạn một cách không cần thiết.
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-06-03 00:00:00 +0000 UTC'>June 3, 2024</span>&nbsp;·&nbsp;<span>4 min</span></footer>
  <a class="entry-link" aria-label="post link to Kỷ Nguyên Mới Của Giao Tiếp: Java HttpClient và Sự Tinh Tế Của Asynchronous" href="http://localhost:1313/posts/java-http-client/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="https://picsum.photos/seed/socketnetwork/1600/900" alt="Network Connection">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Câu Chuyện Về Java Socket: Khi Hai Máy Tính &#39;Thì Thầm&#39; Với Nhau
    </h2>
  </header>
  <div class="entry-content">
    <p>Một buổi chiều mưa và nỗi bi ai của sự cô đơn Hãy tưởng tượng bạn đang ngồi trong một căn phòng trống (máy tính của bạn - localhost), và bạn muốn hét lên một lời chào với thế giới bên ngoài. Nhưng làm sao thế giới nghe thấy bạn được nếu không có cánh cửa nào mở ra? Trong lập trình mạng, cái “cánh cửa” ấy chính là Socket.
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-06-01 00:00:00 +0000 UTC'>June 1, 2024</span>&nbsp;·&nbsp;<span>6 min</span></footer>
  <a class="entry-link" aria-label="post link to Câu Chuyện Về Java Socket: Khi Hai Máy Tính &#39;Thì Thầm&#39; Với Nhau" href="http://localhost:1313/posts/java-socket-programming/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Blog của Hoàng Anh</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
