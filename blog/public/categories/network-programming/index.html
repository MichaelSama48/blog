<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Network Programming | Blog của Hoàng Anh</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/categories/network-programming/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css" integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/categories/network-programming/index.xml" title="rss">
<link rel="alternate" hreflang="en" href="http://localhost:1313/categories/network-programming/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body class="list" id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Blog của Hoàng Anh (Alt + H)">Blog của Hoàng Anh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Network Programming
  </h1>
</header>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="http://localhost:1313/images/p9.jpg" alt="Java Networking Concepts">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java Networking: Mạng máy tính trong Java là gì?
    </h2>
  </header>
  <div class="entry-content">
    <p>Trả lời câu hỏi căn bản nhất: Java Networking thực chất là gì? Nó cung cấp những công cụ gì cho lập trình viên?
Bài viết này sẽ tổng hợp lại bức tranh toàn cảnh về khả năng xử lý mạng của ngôn ngữ Java (J2SE).
1. Networking là gì? Networking (Kết nối mạng) là hành động kết nối hai hoặc nhiều thiết bị máy tính lại với nhau để chia sẻ tài nguyên (như máy in, file) hoặc trao đổi dữ liệu. Trong Java, Networking chủ yếu đề cập đến việc viết các chương trình chạy trên nhiều máy tính và có thể giao tiếp với nhau thông qua giao thức TCP/IP.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-26 00:00:00 +0000 UTC'>December 26, 2025</span>&nbsp;·&nbsp;<span>5 min</span></footer>
  <a class="entry-link" aria-label="post link to Java Networking: Mạng máy tính trong Java là gì?" href="http://localhost:1313/posts/post-9-java-networking-intro/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="http://localhost:1313/images/p8.jpg" alt="Async Processing Diagram">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Lập trình mạng không đồng bộ 
    </h2>
  </header>
  <div class="entry-content">
    <p>Trong lập trình mạng, I/O (Input/Output) là tác vụ chậm nhất. Đọc một file từ ổ cứng mất vài mili-giây, nhưng tải một file từ mạng có thể mất cả giây. Nếu CPU (thứ xử lý được hàng tỷ lệnh mỗi giây) phải ngồi chơi xơi nước chờ mạng tải xong, đó là sự lãng phí tài nguyên khủng khiếp.
Chủ đề này sẽ mổ xẻ hai triết lý giải quyết vấn đề “chờ đợi” (Blocking vs Non-blocking) của hai thế lực: Java (Multithreading) và JavaScript (Event Loop).
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-26 00:00:00 +0000 UTC'>December 26, 2025</span>&nbsp;·&nbsp;<span>5 min</span></footer>
  <a class="entry-link" aria-label="post link to Lập trình mạng không đồng bộ " href="http://localhost:1313/posts/post-8-async-networking/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="http://localhost:1313/images/p7.jpg" alt="API Integration Diagram">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Lập trình mạng với API bên thứ ba 
    </h2>
  </header>
  <div class="entry-content">
    <p>Trong phát triển phần mềm hiện đại, quy tắc vàng là: “Đừng phát minh lại cái bánh xe” (Don’t reinvent the wheel).
Cần bản đồ? Gọi Google Maps API. Cần thanh toán? Gọi Stripe/Momo API. Cần AI? Gọi OpenAI/Gemini API. Cần gửi Email? Gọi SendGrid API. Kỹ năng “gọi API” nghe có vẻ đơn giản (chỉ là gửi một HTTP Request thôi mà?), nhưng để tích hợp tin cậy và hiệu quả trong môi trường Production là một câu chuyện hoàn toàn khác. Bài viết này sẽ chia sẻ những Design Pattern cao cấp khi làm việc với các dịch vụ bên thứ ba.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-26 00:00:00 +0000 UTC'>December 26, 2025</span>&nbsp;·&nbsp;<span>4 min</span></footer>
  <a class="entry-link" aria-label="post link to Lập trình mạng với API bên thứ ba " href="http://localhost:1313/posts/post-7-3rd-party-api/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="http://localhost:1313/images/p5.jpg" alt="Network Security Architecture">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Bảo mật trong lập trình mạng 
    </h2>
  </header>
  <div class="entry-content">
    <p>Trong bốn chủ đề trước, chúng ta đã học cách xây dựng ứng dụng chạy nhanh, kết nối rộng. Nhưng một ứng dụng nhanh mà bảo mật kém thì đó là một thảm họa. Trong bài viết chuyên sâu này, chúng ta sẽ không nói những lời khuyên sáo rỗng như “hãy đặt mật khẩu mạnh”. Chúng ta sẽ đi sâu vào kỹ thuật: Làm sao để mã hóa đường truyền? Làm sao để xác thực (Authentication) và phân quyền (Authorization) trong các hệ thống hiện đại?
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-15 00:00:00 +0000 UTC'>December 15, 2025</span>&nbsp;·&nbsp;<span>5 min</span></footer>
  <a class="entry-link" aria-label="post link to Bảo mật trong lập trình mạng " href="http://localhost:1313/posts/post-5-network-security/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="http://localhost:1313/images/p6.jpg" alt="Microservices Ecosystem">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Lập trình mạng với Microservices và Hệ thống phân tán
    </h2>
  </header>
  <div class="entry-content">
    <p>“Chia để trị” (Divide and Conquer) là một chiến thuật quân sự cổ điển, và nó cũng đúng tuyệt đối trong thiết kế phần mềm hiện đại. Khi một ứng dụng lớn đến mức việc build mất 30 phút, việc fix một bug nhỏ làm sập cả hệ thống, đó là lúc Monolith (Nguyên khối) cần phải nhường chỗ cho Microservices (Vi dịch vụ).
Bài viết này sẽ không chỉ dừng lại ở lý thuyết. Chúng ta sẽ phân tích các design pattern quan trọng nhất để các service “nói chuyện” với nhau một cách tin cậy trong môi trường mạng đầy rẫy rủi ro.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-15 00:00:00 +0000 UTC'>December 15, 2025</span>&nbsp;·&nbsp;<span>4 min</span></footer>
  <a class="entry-link" aria-label="post link to Lập trình mạng với Microservices và Hệ thống phân tán" href="http://localhost:1313/posts/post-6-microservices/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="http://localhost:1313/images/p1.jpg" alt="Network Socket Connection Diagram">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">Lập trình Socket TCP/UDP - Nền tảng cốt lõi của kết nối mạng
    </h2>
  </header>
  <div class="entry-content">
    <p>Trong kỷ nguyên của Cloud Computing và Microservices, chúng ta thường làm việc với các giao thức cấp cao như HTTP, gRPC hay GraphQL. Tuy nhiên, đằng sau lớp vỏ bọc hào nhoáng đó, tất cả đều chạy trên một nền tảng cổ điển nhưng vô cùng vững chắc: Socket.
Hiểu về Socket không chỉ giúp bạn viết code tốt hơn, mà còn cho bạn khả năng “nhìn thấu” những gì đang diễn ra bên trong dây cáp mạng. Tại sao mạng lag? Tại sao kết nối bị đóng? Tại sao game online dùng UDP còn web dùng TCP? Bài viết này sẽ là một chuyến hành trình sâu rộng vào thế giới của Tầng Giao Vận (Transport Layer) với dung lượng hơn 1200 chữ, chi tiết từ lý thuyết đến thực hành.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-15 00:00:00 +0000 UTC'>December 15, 2025</span>&nbsp;·&nbsp;<span>7 min</span></footer>
  <a class="entry-link" aria-label="post link to Lập trình Socket TCP/UDP - Nền tảng cốt lõi của kết nối mạng" href="http://localhost:1313/posts/post-1-tcp-udp-socket/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="http://localhost:1313/images/p3.jpg" alt="REST API Design Diagram">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">RESTful API - Ngôn ngữ chung của Internet
    </h2>
  </header>
  <div class="entry-content">
    <p>Trong kỷ nguyên kết nối, không ưng dụng nào là một hòn đảo. Mobile App cần nói chuyện với Server, Server cần nói chuyện với Database, và Microservices cần nói chuyện với nhau. RESTful API (Representational State Transfer) chính là ngôn ngữ chung (lingua franca) giúp các hệ thống khác biệt về công nghệ có thể hiểu nhau.
Bài viết này không chỉ dạy bạn cách viết @GetMapping. Chúng ta sẽ đi sâu vào triết lý thiết kế REST, những nguyên tắc ngầm (Best Practices) và cách hiện thực hóa chúng một cách chuyên nghiệp nhất trên Java và JavaScript.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-15 00:00:00 +0000 UTC'>December 15, 2025</span>&nbsp;·&nbsp;<span>5 min</span></footer>
  <a class="entry-link" aria-label="post link to RESTful API - Ngôn ngữ chung của Internet" href="http://localhost:1313/posts/post-3-restful-api/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="http://localhost:1313/images/p4.jpg" alt="Real-time WebSocket Connection Diagram">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">WebSocket - Giao tiếp thời gian thực
    </h2>
  </header>
  <div class="entry-content">
    <p>Chúng ta đã nói về HTTP và REST. Chúng tuyệt vời cho việc duyệt web, đọc báo. Nhưng nếu bạn muốn làm một ứng dụng Chat, một Game Online, hay bảng theo dõi chứng khoán nhảy múa liên tục? HTTP trở nên bất lực. Nó quá chậm chạp và thụ động.
Chào mừng bạn đến với thế giới của thiết kế mạng hướng sự kiện (Event-driven Networking) với WebSocket. Bài viết này sẽ không lặp lại những gì cơ bản, chúng ta sẽ đi sâu vào “nội thất” của giao thức này, cách nó bắt tay, cách nó giữ kết nối sống (Keep-alive) và làm sao để mở rộng (Scale) nó lên hàng triệu người dùng.
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-15 00:00:00 +0000 UTC'>December 15, 2025</span>&nbsp;·&nbsp;<span>5 min</span></footer>
  <a class="entry-link" aria-label="post link to WebSocket - Giao tiếp thời gian thực" href="http://localhost:1313/posts/post-4-websocket/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Blog của Hoàng Anh</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
